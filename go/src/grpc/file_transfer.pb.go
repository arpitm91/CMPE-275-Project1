// Code generated by protoc-gen-go. DO NOT EDIT.
// source: file_transfer.proto

package grpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RequestFileList struct {
	IsClient             bool     `protobuf:"varint,1,opt,name=isClient,proto3" json:"isClient,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestFileList) Reset()         { *m = RequestFileList{} }
func (m *RequestFileList) String() string { return proto.CompactTextString(m) }
func (*RequestFileList) ProtoMessage()    {}
func (*RequestFileList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1af68eaa3d01d81, []int{0}
}

func (m *RequestFileList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestFileList.Unmarshal(m, b)
}
func (m *RequestFileList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestFileList.Marshal(b, m, deterministic)
}
func (m *RequestFileList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestFileList.Merge(m, src)
}
func (m *RequestFileList) XXX_Size() int {
	return xxx_messageInfo_RequestFileList.Size(m)
}
func (m *RequestFileList) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestFileList.DiscardUnknown(m)
}

var xxx_messageInfo_RequestFileList proto.InternalMessageInfo

func (m *RequestFileList) GetIsClient() bool {
	if m != nil {
		return m.IsClient
	}
	return false
}

type FileInfo struct {
	FileName             string   `protobuf:"bytes,1,opt,name=fileName,proto3" json:"fileName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileInfo) Reset()         { *m = FileInfo{} }
func (m *FileInfo) String() string { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()    {}
func (*FileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1af68eaa3d01d81, []int{1}
}

func (m *FileInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileInfo.Unmarshal(m, b)
}
func (m *FileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileInfo.Marshal(b, m, deterministic)
}
func (m *FileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileInfo.Merge(m, src)
}
func (m *FileInfo) XXX_Size() int {
	return xxx_messageInfo_FileInfo.Size(m)
}
func (m *FileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FileInfo proto.InternalMessageInfo

func (m *FileInfo) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

type FileUploadInfo struct {
	FileName             string   `protobuf:"bytes,1,opt,name=fileName,proto3" json:"fileName,omitempty"`
	FileSize             float32  `protobuf:"fixed32,2,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileUploadInfo) Reset()         { *m = FileUploadInfo{} }
func (m *FileUploadInfo) String() string { return proto.CompactTextString(m) }
func (*FileUploadInfo) ProtoMessage()    {}
func (*FileUploadInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1af68eaa3d01d81, []int{2}
}

func (m *FileUploadInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileUploadInfo.Unmarshal(m, b)
}
func (m *FileUploadInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileUploadInfo.Marshal(b, m, deterministic)
}
func (m *FileUploadInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileUploadInfo.Merge(m, src)
}
func (m *FileUploadInfo) XXX_Size() int {
	return xxx_messageInfo_FileUploadInfo.Size(m)
}
func (m *FileUploadInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FileUploadInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FileUploadInfo proto.InternalMessageInfo

func (m *FileUploadInfo) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *FileUploadInfo) GetFileSize() float32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

type ChunkInfo struct {
	FileName             string   `protobuf:"bytes,1,opt,name=fileName,proto3" json:"fileName,omitempty"`
	ChunkId              int64    `protobuf:"varint,2,opt,name=chunkId,proto3" json:"chunkId,omitempty"`
	StartSeqNum          int64    `protobuf:"varint,3,opt,name=startSeqNum,proto3" json:"startSeqNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChunkInfo) Reset()         { *m = ChunkInfo{} }
func (m *ChunkInfo) String() string { return proto.CompactTextString(m) }
func (*ChunkInfo) ProtoMessage()    {}
func (*ChunkInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1af68eaa3d01d81, []int{3}
}

func (m *ChunkInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChunkInfo.Unmarshal(m, b)
}
func (m *ChunkInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChunkInfo.Marshal(b, m, deterministic)
}
func (m *ChunkInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChunkInfo.Merge(m, src)
}
func (m *ChunkInfo) XXX_Size() int {
	return xxx_messageInfo_ChunkInfo.Size(m)
}
func (m *ChunkInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ChunkInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ChunkInfo proto.InternalMessageInfo

func (m *ChunkInfo) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *ChunkInfo) GetChunkId() int64 {
	if m != nil {
		return m.ChunkId
	}
	return 0
}

func (m *ChunkInfo) GetStartSeqNum() int64 {
	if m != nil {
		return m.StartSeqNum
	}
	return 0
}

type FileMetaData struct {
	FileName             string   `protobuf:"bytes,1,opt,name=fileName,proto3" json:"fileName,omitempty"`
	ChunkId              int64    `protobuf:"varint,2,opt,name=chunkId,proto3" json:"chunkId,omitempty"`
	Data                 []byte   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	SeqNum               int64    `protobuf:"varint,4,opt,name=seqNum,proto3" json:"seqNum,omitempty"`
	SeqMax               int64    `protobuf:"varint,5,opt,name=seqMax,proto3" json:"seqMax,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileMetaData) Reset()         { *m = FileMetaData{} }
func (m *FileMetaData) String() string { return proto.CompactTextString(m) }
func (*FileMetaData) ProtoMessage()    {}
func (*FileMetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1af68eaa3d01d81, []int{4}
}

func (m *FileMetaData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileMetaData.Unmarshal(m, b)
}
func (m *FileMetaData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileMetaData.Marshal(b, m, deterministic)
}
func (m *FileMetaData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileMetaData.Merge(m, src)
}
func (m *FileMetaData) XXX_Size() int {
	return xxx_messageInfo_FileMetaData.Size(m)
}
func (m *FileMetaData) XXX_DiscardUnknown() {
	xxx_messageInfo_FileMetaData.DiscardUnknown(m)
}

var xxx_messageInfo_FileMetaData proto.InternalMessageInfo

func (m *FileMetaData) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *FileMetaData) GetChunkId() int64 {
	if m != nil {
		return m.ChunkId
	}
	return 0
}

func (m *FileMetaData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *FileMetaData) GetSeqNum() int64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *FileMetaData) GetSeqMax() int64 {
	if m != nil {
		return m.SeqMax
	}
	return 0
}

type FileUploadData struct {
	FileName             string   `protobuf:"bytes,1,opt,name=fileName,proto3" json:"fileName,omitempty"`
	ChunkId              int64    `protobuf:"varint,2,opt,name=chunkId,proto3" json:"chunkId,omitempty"`
	Data                 []byte   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	SeqNum               int64    `protobuf:"varint,4,opt,name=seqNum,proto3" json:"seqNum,omitempty"`
	SeqMax               int64    `protobuf:"varint,5,opt,name=seqMax,proto3" json:"seqMax,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileUploadData) Reset()         { *m = FileUploadData{} }
func (m *FileUploadData) String() string { return proto.CompactTextString(m) }
func (*FileUploadData) ProtoMessage()    {}
func (*FileUploadData) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1af68eaa3d01d81, []int{5}
}

func (m *FileUploadData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileUploadData.Unmarshal(m, b)
}
func (m *FileUploadData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileUploadData.Marshal(b, m, deterministic)
}
func (m *FileUploadData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileUploadData.Merge(m, src)
}
func (m *FileUploadData) XXX_Size() int {
	return xxx_messageInfo_FileUploadData.Size(m)
}
func (m *FileUploadData) XXX_DiscardUnknown() {
	xxx_messageInfo_FileUploadData.DiscardUnknown(m)
}

var xxx_messageInfo_FileUploadData proto.InternalMessageInfo

func (m *FileUploadData) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *FileUploadData) GetChunkId() int64 {
	if m != nil {
		return m.ChunkId
	}
	return 0
}

func (m *FileUploadData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *FileUploadData) GetSeqNum() int64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *FileUploadData) GetSeqMax() int64 {
	if m != nil {
		return m.SeqMax
	}
	return 0
}

type ProxyInfo struct {
	Ip                   string   `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	Port                 string   `protobuf:"bytes,2,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProxyInfo) Reset()         { *m = ProxyInfo{} }
func (m *ProxyInfo) String() string { return proto.CompactTextString(m) }
func (*ProxyInfo) ProtoMessage()    {}
func (*ProxyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1af68eaa3d01d81, []int{6}
}

func (m *ProxyInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProxyInfo.Unmarshal(m, b)
}
func (m *ProxyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProxyInfo.Marshal(b, m, deterministic)
}
func (m *ProxyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyInfo.Merge(m, src)
}
func (m *ProxyInfo) XXX_Size() int {
	return xxx_messageInfo_ProxyInfo.Size(m)
}
func (m *ProxyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyInfo proto.InternalMessageInfo

func (m *ProxyInfo) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *ProxyInfo) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

type FileLocationInfo struct {
	FileName             string       `protobuf:"bytes,1,opt,name=fileName,proto3" json:"fileName,omitempty"`
	MaxChunks            int64        `protobuf:"varint,2,opt,name=maxChunks,proto3" json:"maxChunks,omitempty"`
	LstProxy             []*ProxyInfo `protobuf:"bytes,3,rep,name=lstProxy,proto3" json:"lstProxy,omitempty"`
	IsFileFound          bool         `protobuf:"varint,4,opt,name=isFileFound,proto3" json:"isFileFound,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *FileLocationInfo) Reset()         { *m = FileLocationInfo{} }
func (m *FileLocationInfo) String() string { return proto.CompactTextString(m) }
func (*FileLocationInfo) ProtoMessage()    {}
func (*FileLocationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1af68eaa3d01d81, []int{7}
}

func (m *FileLocationInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileLocationInfo.Unmarshal(m, b)
}
func (m *FileLocationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileLocationInfo.Marshal(b, m, deterministic)
}
func (m *FileLocationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileLocationInfo.Merge(m, src)
}
func (m *FileLocationInfo) XXX_Size() int {
	return xxx_messageInfo_FileLocationInfo.Size(m)
}
func (m *FileLocationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FileLocationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FileLocationInfo proto.InternalMessageInfo

func (m *FileLocationInfo) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *FileLocationInfo) GetMaxChunks() int64 {
	if m != nil {
		return m.MaxChunks
	}
	return 0
}

func (m *FileLocationInfo) GetLstProxy() []*ProxyInfo {
	if m != nil {
		return m.LstProxy
	}
	return nil
}

func (m *FileLocationInfo) GetIsFileFound() bool {
	if m != nil {
		return m.IsFileFound
	}
	return false
}

type FileList struct {
	LstFileNames         []string `protobuf:"bytes,1,rep,name=lstFileNames,proto3" json:"lstFileNames,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileList) Reset()         { *m = FileList{} }
func (m *FileList) String() string { return proto.CompactTextString(m) }
func (*FileList) ProtoMessage()    {}
func (*FileList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1af68eaa3d01d81, []int{8}
}

func (m *FileList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileList.Unmarshal(m, b)
}
func (m *FileList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileList.Marshal(b, m, deterministic)
}
func (m *FileList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileList.Merge(m, src)
}
func (m *FileList) XXX_Size() int {
	return xxx_messageInfo_FileList.Size(m)
}
func (m *FileList) XXX_DiscardUnknown() {
	xxx_messageInfo_FileList.DiscardUnknown(m)
}

var xxx_messageInfo_FileList proto.InternalMessageInfo

func (m *FileList) GetLstFileNames() []string {
	if m != nil {
		return m.LstFileNames
	}
	return nil
}

type ProxyList struct {
	LstProxy             []*ProxyInfo `protobuf:"bytes,1,rep,name=lstProxy,proto3" json:"lstProxy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ProxyList) Reset()         { *m = ProxyList{} }
func (m *ProxyList) String() string { return proto.CompactTextString(m) }
func (*ProxyList) ProtoMessage()    {}
func (*ProxyList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1af68eaa3d01d81, []int{9}
}

func (m *ProxyList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProxyList.Unmarshal(m, b)
}
func (m *ProxyList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProxyList.Marshal(b, m, deterministic)
}
func (m *ProxyList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyList.Merge(m, src)
}
func (m *ProxyList) XXX_Size() int {
	return xxx_messageInfo_ProxyList.Size(m)
}
func (m *ProxyList) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyList.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyList proto.InternalMessageInfo

func (m *ProxyList) GetLstProxy() []*ProxyInfo {
	if m != nil {
		return m.LstProxy
	}
	return nil
}

func init() {
	proto.RegisterType((*RequestFileList)(nil), "grpc.RequestFileList")
	proto.RegisterType((*FileInfo)(nil), "grpc.FileInfo")
	proto.RegisterType((*FileUploadInfo)(nil), "grpc.FileUploadInfo")
	proto.RegisterType((*ChunkInfo)(nil), "grpc.ChunkInfo")
	proto.RegisterType((*FileMetaData)(nil), "grpc.FileMetaData")
	proto.RegisterType((*FileUploadData)(nil), "grpc.FileUploadData")
	proto.RegisterType((*ProxyInfo)(nil), "grpc.ProxyInfo")
	proto.RegisterType((*FileLocationInfo)(nil), "grpc.FileLocationInfo")
	proto.RegisterType((*FileList)(nil), "grpc.FileList")
	proto.RegisterType((*ProxyList)(nil), "grpc.ProxyList")
}

func init() { proto.RegisterFile("file_transfer.proto", fileDescriptor_a1af68eaa3d01d81) }

var fileDescriptor_a1af68eaa3d01d81 = []byte{
	// 498 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x54, 0xc1, 0x8e, 0xd3, 0x30,
	0x10, 0x95, 0x93, 0xb2, 0x24, 0xb3, 0x65, 0x0b, 0x5e, 0x58, 0x45, 0x15, 0x87, 0xc8, 0x07, 0x14,
	0x09, 0x51, 0x50, 0x41, 0x88, 0xe5, 0xba, 0xab, 0x05, 0x24, 0xba, 0x42, 0x2e, 0x9c, 0x91, 0x49,
	0x5d, 0xb0, 0x48, 0xe3, 0x6c, 0xec, 0x42, 0xe1, 0x0b, 0x10, 0xbf, 0xc0, 0x17, 0xf2, 0x17, 0xc8,
	0x93, 0x34, 0x49, 0x97, 0x43, 0x10, 0x97, 0xbd, 0x65, 0x9e, 0xdf, 0xcc, 0x3c, 0x8f, 0xdf, 0x04,
	0x0e, 0x97, 0x2a, 0x93, 0xef, 0x6d, 0x29, 0x72, 0xb3, 0x94, 0xe5, 0xa4, 0x28, 0xb5, 0xd5, 0x74,
	0xf0, 0xb1, 0x2c, 0x52, 0xf6, 0x00, 0x46, 0x5c, 0x5e, 0xac, 0xa5, 0xb1, 0x67, 0x2a, 0x93, 0xaf,
	0x95, 0xb1, 0x74, 0x0c, 0x81, 0x32, 0x27, 0x99, 0x92, 0xb9, 0x8d, 0x48, 0x4c, 0x92, 0x80, 0x37,
	0x31, 0xbb, 0x07, 0x81, 0xe3, 0xbd, 0xca, 0x97, 0xda, 0xf1, 0x5c, 0xdd, 0x73, 0xb1, 0x92, 0xc8,
	0x0b, 0x79, 0x13, 0xb3, 0x97, 0x70, 0xe0, 0x78, 0xef, 0x8a, 0x4c, 0x8b, 0x45, 0x1f, 0x7b, 0x7b,
	0x36, 0x57, 0xdf, 0x65, 0xe4, 0xc5, 0x24, 0xf1, 0x78, 0x13, 0xb3, 0x14, 0xc2, 0x93, 0x4f, 0xeb,
	0xfc, 0x73, 0x6f, 0x91, 0x08, 0xae, 0xa7, 0x48, 0x5c, 0x60, 0x0d, 0x9f, 0x6f, 0x43, 0x1a, 0xc3,
	0xbe, 0xb1, 0xa2, 0xb4, 0x73, 0x79, 0x71, 0xbe, 0x5e, 0x45, 0x3e, 0x9e, 0x76, 0x21, 0xf6, 0x83,
	0xc0, 0xd0, 0xe9, 0x9d, 0x49, 0x2b, 0x4e, 0x85, 0x15, 0xff, 0xd9, 0x88, 0xc2, 0x60, 0x21, 0xac,
	0xc0, 0x0e, 0x43, 0x8e, 0xdf, 0xf4, 0x08, 0xf6, 0x4c, 0xd5, 0x77, 0x80, 0xe4, 0x3a, 0xaa, 0xf1,
	0x99, 0xd8, 0x44, 0xd7, 0x1a, 0x7c, 0x26, 0x36, 0xec, 0x27, 0xe9, 0x8e, 0xee, 0x8a, 0xc5, 0x3c,
	0x84, 0xf0, 0x4d, 0xa9, 0x37, 0xdf, 0x70, 0xf8, 0x07, 0xe0, 0xa9, 0xa2, 0x16, 0xe0, 0xa9, 0xc2,
	0x35, 0x28, 0x74, 0x69, 0xb1, 0x6f, 0xc8, 0xf1, 0x9b, 0xfd, 0x22, 0x70, 0x13, 0x8d, 0xa4, 0x53,
	0x61, 0x95, 0xce, 0x7b, 0x5f, 0xed, 0x2e, 0x84, 0x2b, 0xb1, 0xc1, 0x17, 0x36, 0xf5, 0x0d, 0x5a,
	0x80, 0xde, 0x87, 0x20, 0x33, 0x16, 0x25, 0x44, 0x7e, 0xec, 0x27, 0xfb, 0xd3, 0xd1, 0xc4, 0xd9,
	0x76, 0xd2, 0xa8, 0xe2, 0x0d, 0xc1, 0x3d, 0xb3, 0x32, 0xae, 0xf9, 0x99, 0x5e, 0xe7, 0x0b, 0xbc,
	0x61, 0xc0, 0xbb, 0x10, 0x9b, 0x54, 0xee, 0x45, 0x97, 0x33, 0x18, 0x66, 0x95, 0xe9, 0x9d, 0x0e,
	0x13, 0x91, 0xd8, 0x4f, 0x42, 0xbe, 0x83, 0xb1, 0x67, 0xf5, 0xf5, 0x31, 0xa1, 0xab, 0x85, 0xf4,
	0x68, 0x99, 0xfe, 0xf6, 0xe0, 0xd0, 0xbd, 0xdd, 0xdb, 0x7a, 0xe7, 0xe6, 0xb2, 0xfc, 0xa2, 0x52,
	0x49, 0x8f, 0x77, 0xd6, 0xad, 0x1a, 0x6b, 0x55, 0x65, 0x1b, 0x8f, 0x8f, 0xda, 0x78, 0x67, 0x8a,
	0xc7, 0x30, 0x7a, 0x21, 0x6d, 0x17, 0xfe, 0xe7, 0xd4, 0xa7, 0x70, 0xe3, 0x54, 0x7f, 0xcd, 0x9d,
	0xa1, 0x70, 0xb0, 0xb4, 0x56, 0xde, 0x2c, 0xd6, 0x98, 0xb6, 0x99, 0xdb, 0x1d, 0x78, 0x44, 0xe8,
	0x13, 0x80, 0xca, 0x86, 0x0e, 0xa7, 0xb7, 0x5b, 0x4e, 0x6b, 0xce, 0xf1, 0x25, 0x0d, 0x09, 0xa1,
	0x53, 0x08, 0xdd, 0xc0, 0x1c, 0x62, 0xe8, 0x9d, 0xea, 0xf8, 0xd2, 0x3f, 0xa6, 0x9b, 0x85, 0xc3,
	0x7d, 0x0e, 0xb7, 0x3a, 0x94, 0xaa, 0xfc, 0xdf, 0x0d, 0x51, 0x6a, 0x77, 0xea, 0x2e, 0xf7, 0xc3,
	0x1e, 0xfe, 0xcf, 0x1e, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0xd8, 0x0f, 0xb2, 0xdf, 0xe6, 0x04,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DataTransferServiceClient is the client API for DataTransferService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DataTransferServiceClient interface {
	// From team's client to team's own cluster
	RequestFileInfo(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*FileLocationInfo, error)
	// From team-1 cluster to rest of the nodes of other teams
	GetFileLocation(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*FileLocationInfo, error)
	// From team's client to the actual data-center node (can be any team's node)
	DownloadChunk(ctx context.Context, in *ChunkInfo, opts ...grpc.CallOption) (DataTransferService_DownloadChunkClient, error)
	UploadFile(ctx context.Context, opts ...grpc.CallOption) (DataTransferService_UploadFileClient, error)
	// Interteam request
	ListFiles(ctx context.Context, in *RequestFileList, opts ...grpc.CallOption) (*FileList, error)
	// Request File upload get back proxy list to
	// return proxylist when raft consensus is reached
	RequestFileUpload(ctx context.Context, in *FileUploadInfo, opts ...grpc.CallOption) (*ProxyList, error)
}

type dataTransferServiceClient struct {
	cc *grpc.ClientConn
}

func NewDataTransferServiceClient(cc *grpc.ClientConn) DataTransferServiceClient {
	return &dataTransferServiceClient{cc}
}

func (c *dataTransferServiceClient) RequestFileInfo(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*FileLocationInfo, error) {
	out := new(FileLocationInfo)
	err := c.cc.Invoke(ctx, "/grpc.DataTransferService/RequestFileInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataTransferServiceClient) GetFileLocation(ctx context.Context, in *FileInfo, opts ...grpc.CallOption) (*FileLocationInfo, error) {
	out := new(FileLocationInfo)
	err := c.cc.Invoke(ctx, "/grpc.DataTransferService/GetFileLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataTransferServiceClient) DownloadChunk(ctx context.Context, in *ChunkInfo, opts ...grpc.CallOption) (DataTransferService_DownloadChunkClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DataTransferService_serviceDesc.Streams[0], "/grpc.DataTransferService/DownloadChunk", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataTransferServiceDownloadChunkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataTransferService_DownloadChunkClient interface {
	Recv() (*FileMetaData, error)
	grpc.ClientStream
}

type dataTransferServiceDownloadChunkClient struct {
	grpc.ClientStream
}

func (x *dataTransferServiceDownloadChunkClient) Recv() (*FileMetaData, error) {
	m := new(FileMetaData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataTransferServiceClient) UploadFile(ctx context.Context, opts ...grpc.CallOption) (DataTransferService_UploadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DataTransferService_serviceDesc.Streams[1], "/grpc.DataTransferService/UploadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataTransferServiceUploadFileClient{stream}
	return x, nil
}

type DataTransferService_UploadFileClient interface {
	Send(*FileUploadData) error
	CloseAndRecv() (*FileInfo, error)
	grpc.ClientStream
}

type dataTransferServiceUploadFileClient struct {
	grpc.ClientStream
}

func (x *dataTransferServiceUploadFileClient) Send(m *FileUploadData) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataTransferServiceUploadFileClient) CloseAndRecv() (*FileInfo, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(FileInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataTransferServiceClient) ListFiles(ctx context.Context, in *RequestFileList, opts ...grpc.CallOption) (*FileList, error) {
	out := new(FileList)
	err := c.cc.Invoke(ctx, "/grpc.DataTransferService/ListFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataTransferServiceClient) RequestFileUpload(ctx context.Context, in *FileUploadInfo, opts ...grpc.CallOption) (*ProxyList, error) {
	out := new(ProxyList)
	err := c.cc.Invoke(ctx, "/grpc.DataTransferService/RequestFileUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataTransferServiceServer is the server API for DataTransferService service.
type DataTransferServiceServer interface {
	// From team's client to team's own cluster
	RequestFileInfo(context.Context, *FileInfo) (*FileLocationInfo, error)
	// From team-1 cluster to rest of the nodes of other teams
	GetFileLocation(context.Context, *FileInfo) (*FileLocationInfo, error)
	// From team's client to the actual data-center node (can be any team's node)
	DownloadChunk(*ChunkInfo, DataTransferService_DownloadChunkServer) error
	UploadFile(DataTransferService_UploadFileServer) error
	// Interteam request
	ListFiles(context.Context, *RequestFileList) (*FileList, error)
	// Request File upload get back proxy list to
	// return proxylist when raft consensus is reached
	RequestFileUpload(context.Context, *FileUploadInfo) (*ProxyList, error)
}

func RegisterDataTransferServiceServer(s *grpc.Server, srv DataTransferServiceServer) {
	s.RegisterService(&_DataTransferService_serviceDesc, srv)
}

func _DataTransferService_RequestFileInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataTransferServiceServer).RequestFileInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.DataTransferService/RequestFileInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataTransferServiceServer).RequestFileInfo(ctx, req.(*FileInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataTransferService_GetFileLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataTransferServiceServer).GetFileLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.DataTransferService/GetFileLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataTransferServiceServer).GetFileLocation(ctx, req.(*FileInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataTransferService_DownloadChunk_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChunkInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataTransferServiceServer).DownloadChunk(m, &dataTransferServiceDownloadChunkServer{stream})
}

type DataTransferService_DownloadChunkServer interface {
	Send(*FileMetaData) error
	grpc.ServerStream
}

type dataTransferServiceDownloadChunkServer struct {
	grpc.ServerStream
}

func (x *dataTransferServiceDownloadChunkServer) Send(m *FileMetaData) error {
	return x.ServerStream.SendMsg(m)
}

func _DataTransferService_UploadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataTransferServiceServer).UploadFile(&dataTransferServiceUploadFileServer{stream})
}

type DataTransferService_UploadFileServer interface {
	SendAndClose(*FileInfo) error
	Recv() (*FileUploadData, error)
	grpc.ServerStream
}

type dataTransferServiceUploadFileServer struct {
	grpc.ServerStream
}

func (x *dataTransferServiceUploadFileServer) SendAndClose(m *FileInfo) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataTransferServiceUploadFileServer) Recv() (*FileUploadData, error) {
	m := new(FileUploadData)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataTransferService_ListFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestFileList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataTransferServiceServer).ListFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.DataTransferService/ListFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataTransferServiceServer).ListFiles(ctx, req.(*RequestFileList))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataTransferService_RequestFileUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileUploadInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataTransferServiceServer).RequestFileUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.DataTransferService/RequestFileUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataTransferServiceServer).RequestFileUpload(ctx, req.(*FileUploadInfo))
	}
	return interceptor(ctx, in, info, handler)
}

var _DataTransferService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.DataTransferService",
	HandlerType: (*DataTransferServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestFileInfo",
			Handler:    _DataTransferService_RequestFileInfo_Handler,
		},
		{
			MethodName: "GetFileLocation",
			Handler:    _DataTransferService_GetFileLocation_Handler,
		},
		{
			MethodName: "ListFiles",
			Handler:    _DataTransferService_ListFiles_Handler,
		},
		{
			MethodName: "RequestFileUpload",
			Handler:    _DataTransferService_RequestFileUpload_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DownloadChunk",
			Handler:       _DataTransferService_DownloadChunk_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UploadFile",
			Handler:       _DataTransferService_UploadFile_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "file_transfer.proto",
}
